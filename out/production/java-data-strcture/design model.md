#设计模式的内容
##第一章接口与抽象类
    ###1.1语义简单描述
    接口与抽象类是面向对象思想的两个重要概念。接口仅是方法定义和常量值定义的集合，方法没有函数体；抽象类定义的内容理论上比接口中的
        内容要多得多，可定义普通类所包含的所有内容，还可定义抽象方法，这也正是叫作抽象类的原因所在。接口、抽象类本身不能示例化，必
        须在相应子类中实现抽象方法，才能获得应用
    Java语言一定要反映“思考-实现”这一过程，通过不同关键字来实现，即用接口（interface）、抽象类（abstract）来反映思考阶段，用子类
        （class）来反映实现阶段
    为什么接口、抽象类不能示例化？由于接口、抽象类是思考的结果，只是提出了哪些问题需要解决，无需函数体具体内容，当然不能示例化了
    接口、抽象类有什么区别？可以这样考虑，人类经思考后提出的问题一般有两类：一类是“顺序”问题，另一类是“顺序+共享”问题。前者是用接
        口描述的，后者是用抽象类来描述的
    工序是顺序关系，因此转化成接口是最恰当的
    ###1.2与框架的关系
    接口、抽象类代表了提出的两类问题的抽象字符描述。这是理解接口、抽象类的基础，是编制框架的关键。框架包括方法框架与流程框架
    ###1.3拓展研究
##第二章反射
    Java反射（Java Reflection）是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，
        还包括示例的创建和示例类型的判断等    
    反射技术的编程特点：大大提高了编制稳定框架的能力。具体表现在，当新增加功能的时候，仅增加相应的功能类，而框架调用可能不需要发生变化
##第三章工厂模式
 工厂模式一般分为简单工厂、工厂、抽象工厂3种情况，属于创建型设计模式。
使用简单工厂的时候，通常不用创建简单工厂类的类示例，没有创建示例的必要。因此可以把简单工厂类实现成一个工具类，直接使用静态方法就可以了。也就是说，简单工厂的方法通常是静态的，所以也被称为静态工厂。如果要防止客户端无谓地创造简单工厂示例，还可以把简单工厂的构造方法私有化。
如果现在又新增了一个超高档类型的汽车，在简单工厂模式下，需要做的工作有：①新增ICar的子类SuperCar; ②修改工厂类SimpleCarFactory中的create()方法，增加SuperCar对象的判断选择分支。
   ● 工厂模式把简单工厂中具体的工厂类（如CarSimpleFactory）划分成两层：抽象工厂层（如AbstractFactory）+具体工厂子类层（如TopFactory等）。抽象工厂层的划分丰富了程序框架的内涵，符合从一般到特殊的语义特点。
 ##生成器模式
在类的应用中，有些类是容易创建对象的，直接调用构造方法即可。例如，Student obj =new Student(“1001”,“张三”,20)，表明学生学号是1001，姓名是张三，年龄20; Circle obj2 = new Circle(10.0f)，表明创建一个半径是10的圆对象。这两个类的一大特点是成员变量是基本数据类型或其封装类，或是字符串类。有些类是不易直接创建对象的，成员变量是自定义类型，代码如下
可以看出，Product由Unit1、Unit2、Unit3三个单元组成，产生Product对象不能简单地由Product obj=new Product(Unit1, Unit2, Unit3)获得，必须先产生具体的对象u1、u2、u3，然后才能获得Product对象
可以看出，随着Product产品种类的增多或减少，必须修改已有的源代码。这是我们不希望看到的情况，如何解决呢？生成器模式是解决这类问题的重要手段。
##观察者模式
在生活实际中，经常会遇到多种对象关注一个对象数据变化的情况。例如，生活中有温度记录仪，当温度发生变化时，需要完成如下功能：记录温度日志，显示温度变化曲线，当温度越界时扬声器发出声音。
这种方法把所有功能集成在一起，当需求分析发生变化，例如，增加新的温度监测功能或舍去某一监测功能时，程序都得修改，这是我们所不希望的结果。观察者设计模式是解决这类问题的有效方法。
观察者设计模式可以从以下递推中得出一些重要结论。● 主题要知道有哪些观察者对其进行监测，因此主题类中一定有一个集合类成员变量，包含了观察者的对象集合。● 既然包含了观察者的对象集合，那么，观察者一定是多态的，有共同的父类接口。● 主题完成的主要功能是：可以添加观察者，可以撤销观察者，可以向观察者发消息，引起观察者响应。这三个功能是固定的，因此主题类可以从固定的接口派生。因此，编制观察者设计模式，要完成以下功能类的编制。● 主题ISubject接口定义。● 主题类编制。● 观察者接口IObserver定义。● 观察者类实现。
##桥接模式
桥接模式是关于怎样将抽象部分与它的实现部分分离，使它们都可以独立地变化的成熟模式。6.1节中方法1、方法2的根本缺陷是：在具体类中都封装了F1()或F2()方法。因此，一定有许多重复的代码。解决该问题的一个重要策略仍是利用语义，进一步抽象图6-1所示功能。可描述为：邮局有发送功能；发送有两种方式，平邮和挂号；具体事物可为信件和包裹。因此，主要把上述关键字转译成如下程序代码即可。
在6.1节中，一直用的是F1()、F2()方法，没有把它抽象化。其实F1()、F2()都是邮寄方法，所以是可进一步抽象的。IPost相当于语义“邮局”, post()相当于“发送”。也许仍有许多读者认为：“你写出来，我就理解了；你没写出来，我就想不到”。造成这种情况的根本原因是把程序与生活实际割裂开来。其实，只要一想到“邮局有邮寄功能”，把它转译一下，不就是接口IPost吗？
该类是桥接模式的核心。分析语义“信件和包裹共享平邮与挂号功能”：信件、包裹是两个不同的事物，它们有共享的功能，也一定有相异的功能。共享的功能一定能封装到一个类中，又由于该类不能代表一个具体的事物，所以把它定义成abstract类是恰当的。该类共享的是多态成员obj，是IPost类型的，是抽象的、泛指的，用一条语句表明了事物共享平邮和发送功能。    
##代理模式
在生活中常遇到这样的事情：长虹电视的原产地在四川，你在大连工作，准备买长虹电视，那么你一定会在大连的商店或相关部门购买，而不会去四川购买；你去北京求职，一定会先到求职中心；你准备买车，一定会先去4S店；等等。可能你会说这类问题太司空见惯了。仔细分析会发现这类事件的一个重大特点，那就是客户都没有和“源产地”直接接触，而是通过一个称为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。代理模式则是一种可以很好实现客户对象与代理对象分离的策略。
代理模式的定义如下：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫作Proxy或Surrogate，它是一种对象结构型模式。
● ISubject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。● RealSubject：真实主题角色，是实现抽象主题接口的类。● Proxy：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。以买电视为例，其代码如下。
电视代理商BuyerProxy与购买者Buyer都实现了相同的接口ITV，是对Buyer对象的进一步封装。着重理解buyTV()方法：首先代理商要通过preProcess()询问客户买电视的类型、价位等信息，然后购买者通过buyer.buyTV()自己付费完成电视购买，最后代理商通过postProcess()协商具体的送货服务、产品三包等。代理模式最突出的特点是：代理角色与实际主题角色有相同的父类接口。常用的代理方式有4类：虚拟代理、远程代理、计数代理、动态代理，下面一一加以说明。
虚拟代理的关键思想是：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。当用户请求一个“大”对象时，虚拟代理在该对象真正被创建出来之前扮演着替身的角色；当该对象被创建出来之后，虚拟代理就将用户的请求直接委托给该对象。
远程代理的含义是：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可在另一台主机中。也就是说，远程对象驻留于服务器上，客户机请求调用远程对象调用相应方法，执行完毕后，结果由服务器返回给客户端。
虚拟代理一般有一个代理，而远程代理包括两个代理：客户端通信代理与服务器端通信代理，因此编程中必须考虑这两部分因素，但是实际上JDK已经提供了远程代理的通信框架，如RMI(Remote Method Invocation)远程方法调用、CORBA(CommonObject Broker Architecture)公用对象请求代理体系结构技术等。这意味着编程时无须考虑远程代理的编码了，只编制所需的普通代码即可，甚至比虚拟代理编码都要简单许多。可能有读者疑问：远程代理部分负责信息的编码、传递、解码等功能，应该是非常复杂的，怎么可能被屏蔽掉，在编程时不考虑呢？其实，联系生活实际，就能有很好的感性认识。例如，你从大连邮寄包裹到北京，只需到大连邮局申请并登记一下就可以了，无须考虑北京到大连是如何邮寄的，那是“大连邮局代理”与“北京邮局代理”负责的事。
##装饰器模式
在消息日志功能中，接收到的消息可以直接送往屏幕显示，也可以用文件保存，其功能类UML类图如图11-1所示。

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        
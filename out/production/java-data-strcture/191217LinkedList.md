####昨日代码总结
#####环形队列
    1.使用循环数组注意时刻提醒自己应该用%maxSize
#链表
    1.链表是以节点方式来存储，
    2.节点包含两个域，一个是data，一个是next
    3.链表中的节点不一定是连续的
    4.链表分为带头节点的链表和不带头节点的链表
##单向链表
    1.添加只添加到对尾
    2.添加到指定位置
###节点
    1.头节点：不存储数据，作用是作为链表头
    2.数据节点：存储数据和下一个节点的地址
    3.尾节点：数据为null
####添加到指定位置
    1.首先找到新添加的节点的位置,通过辅助变量
    2.新的节点.next = temp.next
    将temp.next = 新的节点
####删除指定的节点
    1.需要辅助的节点寻找删除节点的前一个节点
    2.temp.next = temp.next.next
    3.被删除的节点，将不会有其他引用指向，将会被垃圾回收机制回收
#####要点补充：java中单双引号的区别
    1.java中的单引号表示字符,java中的双引号是字符串。
    2.单引号引的数据一般是char类型的;双引号引的数据 是String类型的。
    3.java中单引号里面只能放一个字母或数字或符号;
    4.java中的双引号里面是0到多个字符构成。所以字符可以直接转换成字符串。字符串需要使用charAt(n) 来获取第几个字符。
#####java中的垃圾回收机制
    1.回顾jvm中的内存结构：五大内存区域，只需要关注java堆和方法区
    2.确定哪些对象是垃圾：引用计数法，可达性分析，可达性分析的boot节点
    虚拟机栈（帧栈中的本地变量表）中引用的对象。
    方法区中静态属性引用的对象。
    方法区中常量引用的对象。
    本地方法栈中 JNI 引用的对象。
    3.垃圾的回收算法：1.标记-清理2.标记-整理3.复制
    方法区的垃圾回收：分为废弃常量和无用的类垃圾
        废弃常量：没有任何一个地方对这个常量再进行引用
        无用的类：java中不含有他的实例，加载该类的classloader已经被回收，class对象不再被引用
        ***类回收不是强制回收
    java堆的垃圾回收：分代回收算法，java堆的三部分：刚刚创建的对象，存活了一段时间的对象，永久存在的对象
        新生代：复制回收机制首先，Eden对外提供堆内存。当 Eden区快要满了，触发垃圾回收机制，把存活对象放入 Survivor A 区，清空 Eden 区；
                  Eden区被清空后，继续对外提供堆内存；当 Eden 区再次被填满，对 Eden区和 Survivor A 区同时进行垃圾回收，把存活对象放入 Survivor B区，同时清空 Eden 区和Survivor A 区；
                  当某个 Survivor区被填满，把多余对象放到Old 区；
                  当 Old 区也被填满时，进行 下一阶段的垃圾回收
        老年代：标记整理，回收机制
    4.jvm中的垃圾回收器：
        吞吐量：运行代码时间/总时间
        停顿时间：垃圾回收期运行时应用程序的暂停时间
        Minor GC/Major GC
        串行：两者线程在一起
        并发：线程交替进行
        并行：不同CPU分别运行

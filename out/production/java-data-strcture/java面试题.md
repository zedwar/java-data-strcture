1）ClassLoader基本概念
与C或C++编写的程序不同，Java程序并不是一个可执行文件，而是由许多独立的类文件组成的，每一个文件对应一个Java类。此外，这些类文件并非全部装入内存，而是根据程序需要逐渐载入。ClassLoader是JVM实现的一部分，ClassLoader包括bootstrap classloader（启动类加载器），ClassLoader在JVM运行的时候加载Java核心的API，以满足Java程序最基本的需求，其中就包括用户定义的ClassLoader，这里所谓的用户定义，是指通过Java程序实现的两个ClassLoader：一个是ExtClassLoader，它的作用是用来加载Java的扩展API，也就是/lib/ext中的类；第二个是AppClassLoader，它是用来加载用户机器上CLASSPATH设置目录中的Class的，通常在没有指定ClassLoader的情况下，程序员自定义的类就由该ClassLoader进行加载。
（2）ClassLoader加载流程
当运行一个程序的时候，JVM启动，运行bootstrap classloader，该ClassLoader加载Java核心API（ExtClassLoader和AppClassLoader也在此时被加载），然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class，这就是一个程序最基本的加载流程。
一个类加载的过程使用了一种父类委托模式。为什么要使用这种父类委托模式呢？第1个原因就是这样可以避免重复加载，当父类已经加载了该类的时候，就没有必要子ClassLoader再加载一次。第2个原因就是考虑到安全因素，如果不使用这种委托模式，那么可以随时使用自定义的String来动态替代Java核心API中定义的类型，这样会存在非常大的安全隐患，而父类委托的方式就可以避免这种情况，因为String已经在启动时被加载，所以，用户自定义类是无法加载一个自定义的ClassLoader。
（3）一些重要的方法1）loadClass方法。ClassLoader.loadClass() 是ClassLoader的入口点。2）defineClass方法。defineClass方法接受由原始字节组成的数组，并把它转换成Class对象。原始数组包含如从文件系统或网络装入的数据。defineClass管理JVM的许多复杂的实现层面——它把字节码分析成运行时数据结构、校验有效性等。因为defineClass方法被标记成final的，所以也不能覆盖它。3）findSystemClass方法。findSystemClass方法从本地文件系统装入文件。它在本地文件系统中寻找类文件，如果存在，就使用defineClass将原始字节转换成Class对象，以将该文件转换成类。当运行Java应用程序时，这是JVM正常装入类的默认机制。对于定制的ClassLoader，只有在尝试其他方法装入类之后，再使用findSystemClass。这是因为ClassLoader是负责执行装入类的相关步骤，不负责所有类的所有信息。4）resolveClass方法。正如前面所提到的，可以不完全地（不带解析）装入类，也可以完全地（带解析）装入类。当编写我们自己的loadClass时，可以调用resolveClass，这取决于loadClass的resolve参数的值。5）findLoadedClass方法。findLoadedClass充当一个缓存：当请求loadClass装入类时，它调用该方法来查看ClassLoader是否已装入这个类，这样可以避免重新装入已存在类所造成的麻烦。6）findClass方法。loadClass默认实现调用这个新方法。findClass的用途包含ClassLoader的所有特殊代码，而无须复制其他代码（例如，当专门的方法失败时，调用系统ClassLoader）。目的是从本地文件系统使用实现的类装载器装载一个类。为了创建自己的类装载器，应该扩展ClassLoader类，这是一个抽象类。可以创建一个FileClassLoaderextends ClassLoader，然后覆盖ClassLoader中的findClass(String name)方法，这个方法通过类的名字得到一个Class对象。
Java开发者必须牢记：在Java中字符只以一种形式存在，那就是Unicode（不选择任何特定的编码，直接使用它们在字符集中的编号，这是统一的唯一方法）
但“在Java中”到底是指在哪里呢？是指在JVM中、在内存中、在你的代码里声明的每一个char、String类型的变量中
JVM的这种约定使得一个字符分为两部分：JVM内部和OS的文件系统。在JVM内部，统一使用Unicode表示，当这个字符被从JVM内部移到外部（即保存为文件系统中的一个文件的内容时），就进行了编码转换，使用了具体的编码方案。因此可以说，所有的编码转换只发生在边界的地方，JVM和OS的交界处，也就是各种输入/输出流（或者Reader，Writer类）起作用的地方。
Java的数据类型分为三大类，即布尔型、字符型和数值型，其中，数值型又分为整型和浮点型。相对于数据类型，Java的变量类型为布尔型boolean；字符型char；整型byte、short、int、long；浮点型float、double。其中四种整型变量和两种浮点型变量分别对应于不同的精度和范围。此外，编程时还经常用到两种类变量，即String和Date。
（1）数据类型转换的种类Java数据类型的转换一般分三种，分别是：简单数据类型之间的转换、字符串与其他数据类型的转换、其他实用数据类型的转换。（2）简单数据类型之间的转换在Java中，整型、实型、字符型被视为简单数据类型，这些类型由低级到高级分别为(byte，short，char)—int—long—float—double。简单数据类型之间的转换又可以分为：低级到高级的自动类型转换、高级到低级的强制类型转换、包装类过渡类型能够转换。
Java的包装类就是可以直接将简单类型的变量表示为一个类。Java共有六个包装类，分别是Boolean、Character、Integer、Long、Float和Double，从字面上可以看出它们分别对应于boolean、char、int、long、float和double。而String和Date本身就是类，不存在包装类的概念。在进行简单数据类型之间的转换（自动转换或强制转换）时，可以利用包装类进行中间过渡。一般情况下，首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换了。
4.异常处理中常见的问题（1）过于庞大的try块某些程序员把大量的代码放入单个try块，试图用一个catch语句捕获所有的异常和处理所有可能出现的异常，实际上这是一个坏习惯。原因就在于为了图省事，不愿花时间分析一大块代码中哪几行代码会抛出异常、异常的具体类型是什么。把大量的语句装入单个巨大的try块就像是出门旅游时把全部家当塞入集装箱带走，虽然东西是带上了，但要找出来可不容易。对于这种问题，可以设置多个异常抛出点来解决。异常对象从产生点产生后，到被捕捉后终止生命的全过程中，实际上是一个传值过程，所以，应根据实际来合理控制检测异常个数。catch语句表示会出现某种异常，而且希望能够处理该异常。所以在catch语句中就应该尽量指定具体异常类型，也可使用多个catch，用于分别处理不同的异常。例如，要捕获一个最明显的异常是SQLException，这是JDBC操作中常见的异常。另一个可能的异常是IOException，因为它要操作OutputStreamWriter。显然，在同一个catch块中处理这两种截然不同的异常是不合适的。如果用两个catch块分别捕获SQLException和IOException就要好多了。（2）异常的完整性在Java语言中，如果一个函数运行时可能会向上层调用者函数抛出一个异常，那么，它就必须在该函数的声明中显式地注明（采用throws关键字）。否则编译器会报出错误信息“must be caught or declared to bethrown”。其中“must be caught”指在Java的异常处理模型中，要求所有被抛出的异常都必须有对应的“异常处理模块”。如果你在程序中利用throw出现一个异常，那么在你的程序（函数）中就必须要用catch处理这个异常。例如下面的例子中，抛出了一个Exception类型的异常，所以在该函数中，就必须有一个catch，并处理此异常。如果没有这个catch，Java语言在编译时就直接拦住这种可能出现错误的情况，不让程序通过
谈谈final、finally、finalize的区别。解析：1.finalfinal可以用于控制成员、方法，或者是一个类是否可被覆写或继承等功能，这些特点使final在Java中拥有了一个不可或缺的地位，也是学习Java时必须要知道和掌握的关键字之一。（1）final成员当在类中定义变量时，若在其前面加上final关键字，那就是说，这个变量一旦被初始化，便不可改变，这里不可改变的意思对基本类型来说是其值不可变，而对于对象变量来说是其引用不可变。其初始化可以在两个地方，一是其定义处，二是在构造函数中，两者只能选其一。还有一种用法是定义方法中的参数为final。对于基本类型的变量，这样做并没有什么实际意义，因为基本类型的变量在调用方法时是传值的，也就是说，你可以在方法中更改这个参数变量而不会影响到调用语句，然而对于对象变量，却显得很实用，因为对象变量在传递时是传递其引用的，这样，你在方法中对对象变量的修改也会影响到调用语句中的对象变量。当你在方法中不需要改变作为参数的对象变量时，明确使用final进行声明，会防止你无意地修改而影响到调用方法。（2）final方法将方法声明为final有两个原因，第一就是说明已经知道这个方法提供的功能满足要求，不需要进行扩展，并且也不允许任何从此类继承的类来覆写这个方法，但是仍然可以继承这个方法，也就是说，可以直接使用。第二就是允许编译器将所有对此方法的调用转化为inline（行内）调用的机制，它会在调用final方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用，例如，保存断点、压栈等，这样可能会使程序效率有所提高。然而当方法主体非常庞大时，或在多处调用此方法时，调用主体代码便会迅速膨胀，可能反而会影响效率，所以要慎用final进行方法定义。（3）final类当将final用于类时，就需要仔细考虑，因为一个final类是无法被任何人继承的，那也就意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美，不需要进行修改或扩展。对于final类中的成员，可以定义其为final，也可以不是final。而对于方法，由于所属类为final的关系，自然也就成了final型的。也可以明确地给final类中的方法加上一个final，但这显然没有意义。
2.finally关键字是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管有无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。如果没有finally，你的代码就会很费解。
3.finalize根据Java语言规范，JVM保证调用finalize函数之前，这个对象是不可达的，但是JVM不保证这个函数一定会被调用。另外，规范还保证finalize函数最多运行一次。通常，finalize用于一些不容易控制，并且非常重要的资源的释放，例如，一些I/O的操作、数据的连接。这些资源的释放对整个应用程序是非常关键的。在这种情况下，程序员应该以通过程序本身管理（包括释放）这些资源为主，以finalize函数释放资源方式为辅，形成一种双保险的管理机制，而不应该仅仅依靠finalize来释放资源。
什么是Reflection（反射）
反射主要是指程序可以访问、检测和修改它本身的状态或行为的一种能力。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用，并在LISP和面向对象方面取得了成绩，其中LEAD/LEAD++、OpenC++、MetaXa和OpenJava等就是基于反射机制的语言。最近，反射机制也被应用到了视窗系统、操作系统和文件系统中。
Java中的反射是一种强大的工具，它能够创建灵活的代码，这些代码可以在运行时装配，无须在组件之间进行链接。反射允许在编写与执行时，使程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活应用的主要工具。需注意的是，如果使用不当，反射的成本会很高。
Java中是传值还是传引用
在Java中，变量分为以下两类。① 对于基本类型变量（int、long、double、float、byte、boolean、char），Java是传值的副本。（这里Java和C++相同。）② 对于一切对象型变量，Java都是传引用的副本。其实，传引用副本的实质就是复制指向地址的指针，只不过Java不像C++中有显著的*和&符号。（这里Java和C++不同，在C++中，当参数是引用类型时，传递的是真实引用而不是引用副本。）
在Java的I/O结构中，RandomAccessFile是比较不寻常的类，它直接继承于Object，它并不属于Streams结构的一部分。
如何实现Java的序列化
序列化一个对象还是比较简单的，只要让它实现Serializable接口就行了（这是一个“标记接口”，tagging interface，没有任何方法）。但是，当语言引入序列化概念之后，它的很多标准类库的类，包括primitive的wrapper类、所有的容器类，以及别的很多类，都会相应地发生改变，甚至连Class对象都会被序列化。要想序列化对象，必须先创建一个OutputStream，然后把它嵌进ObjectOutputStream。这时就能用writeObject( )方法把对象写入OutputStream。读的时候需要把InputStream嵌到ObjectInputStream中，然后再调用readObject( )方法。不过这样读出来的只是一个Object的reference，因此，在用之前，还得先下传。对象序列化不仅能保存对象的副本，而且还会跟着对象中的reference把它所引用的对象也保存起来，然后再继续跟踪那些对象的reference，以此类推。这种情形常被称为“单个对象所联结的‘对象网’”。这个机制所涵盖的范围不仅包括对象的成员数据，而且还包含数组里面的reference。如果要自己实现对象序列化，那么编写跟踪这些链接的程序将会是一件非常痛苦的任务。但是，Java的对象序列化就能精确无误地做到这一点，毫无疑问，它的遍历算法是做过优化的。
Java中的垃圾收集器相对于以前的语言的优势是什么
过去的语言（如C语言）要求程序员显式地分配内存、释放内存。程序在需要时分配内存，不需要时释放内存。但是这种做法常常引起“内存泄漏”，即由于某种原因使分配的内存始终没有得到释放。如果该任务不断地重复，程序最终会耗尽内存并异常终止，至少无法继续运行。相比之下，Java不要求程序员显式地分配内存和释放内存，避免了很多潜在问题。Java在创建对象时会自动分配内存，并当该对象的引用不存在时释放这块内存。Java中使用被称为垃圾收集器的技术来监视Java程序的运行，当对象不再使用时，就自动释放对象所使用的内存。Java使用一系列软指针来跟踪对象的各个引用，并用一个对象表将这些软指针映射为对象的引用。之所以称为软指针，是因为这些指针并不直接指向对象，而是指向对象的引用。使用软指针，Java的垃圾收集器能够以单独的线程在后台运行，并依次检查每个对象。通过更改对象表项，垃圾收集器可以标记对象、移除对象、移动对象或检查对象。垃圾收集器是自动运行的，一般情况下，无须显式地请求垃圾收集器。程序运行时，垃圾收集器会不时检查对象的各个引用，并回收无引用对象所占用的内存。调用System类中的静态gc()方法可以运行垃圾收集器，但这样并不能保证立即回收指定对象。
Java垃圾回收机制：gc即垃圾收集机制，是指JVM用于释放那些不再使用的对象所占用的内存。Java语言并不要求JVM有gc，也没有规定gc如何工作。不过常用的JVM都有gc，而且大多数gc都使用类似的算法管理内存和执行收集操作。Java的垃圾回收机制是为所有的Java应用进程服务的，而不是为某个特定的进程服务的。因此，任何一个进程都不能命令垃圾回收机制做什么、怎么做或做多少。在JVM垃圾收集器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了默认机制终止化该对象来释放资源，这个方法就是finalize()。它的原型为protected void finalize() throws Throwable。在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。
如果有一个对象的句柄a，且你把a作为某个构造器的参数，即newConstructor (a)，则即使你将a赋值为null，a也不符合垃圾收集器的收集标准。直到由上面构造器构造的新对象被赋空值时，a才可以被垃圾收集器收集。
在Java语言中，判断一块内存空间是否符合垃圾收集器收集标准的标准只有以下两个：（1）给对象赋予了空值null，以后再没有调用过。（2）给对象赋予了新值，即重新分配了内存空间。
我们在使用垃圾回收时需要注意以下几点，或许可以作为写程序时的准则。（1）不要试图去假定垃圾收集发生的时间，这一切都是未知的。比如，方法中的一个临时对象在方法调用完毕后就变成了无用对象，这个时候它的内存就可以被释放。（2）Java中提供了一些和垃圾收集打交道的类，而且提供了一种强行执行垃圾收集的方法—调用System.gc()，但这同样是一个不确定的方法。Java中并不保证每次调用该方法就一定能够启动垃圾收集，它只不过会向JVM发出这样一个申请，到底是否真正执行垃圾收集，一切都是个未知数。（3）挑选适合自己的垃圾收集器。一般来说，如果系统没有特殊和苛刻的性能要求，可以采用JVM的默认选项。否则可以考虑使用有针对性的垃圾收集器，比如增量收集器就比较适用于实时性要求较高的系统中。若系统具有较高的配置，有比较多的闲置资源，可以考虑使用并行标记/清除收集器。（4）关键的也是难把握的问题是内存泄漏。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。（5）尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的对象是否被监听，如果是，则要去掉监听器，然后再赋空值。就是说，对于频繁申请内存和释放内存的操作，还是自己控制一下比较好，但是System.gc()的方法不一定适用，最好使用finalize强制执行或者写自己的finalize方法。
Java是如何管理内存的
Java的内存管理就是对象的分配和释放问题。在Java中，程序员需要通过关键字new为每个对象申请内存空间（基本类型除外），所有的对象都在堆（Heap）中分配空间。另外，对象的释放是由GC决定和执行的。在Java中，内存的分配是由程序完成的，而内存的释放是由GC完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是Java程序运行速度较慢的原因之一。因为GC为了能够正确释放对象，必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC都需要进行监控。
监视对象状态是为了更加准确、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。为了更好地理解GC的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引用对象。另外，每个线程对象可以作为一个图的起始顶点，例如，大多程序从main进程开始执行，那么该图就是以main进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象（连通子图）与这个根顶点不可达（注意，该图为有向图），那么我们认为这个（这些）对象不再被引用，可以被GC回收。
什么是Java中的内存泄漏
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点：① 对象是可达的，即在有向图中，存在通路可以与其相连；② 对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它们却占用内存。在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此，程序员不需要考虑这部分内存泄漏。对于C++，程序员需要自己管理边和顶点，而对于Java程序员，只需要管理边就可以了（不需要管理顶点的释放）。通过这种方式，Java提高了编程的效率。
对于程序员来说，GC基本是透明的、不可见的。虽然我们只有几个函数可以访问GC，例如，运行GC的函数System.gc()，但是根据Java语言规范定义，该函数不保证JVM的垃圾收集器一定会执行。因为不同的JVM实现者可能使用不同的算法管理GC。通常，GC线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些，除非在一些特定的场合，GC的执行影响应用程序的性能，例如，对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序的执行而进行垃圾回收，那么需要调整GC的参数，让GC能够通过平缓的方式释放内存
内存泄漏主要由什么引起？都有什么样的情况
典型的内存泄漏及其原因如下。1.全局集合在大的应用程序中有某种全局的数据储存库是很常见的，例如，一个JNDI树或一个会话表。在这些情况下，必须注意管理储存库的大小。必须有某种机制使得从储存库中移除不再需要的数据。这可能有多种方法，但是最常见的一种是周期性运行的某种清除任务，该任务将验证储存库中的数据，并移除任何不再需要的数据。另一种管理储存库的方法是使用反向链接（referrer）计数，然后集合负责统计集合中每个入口的反向链接的数目。这要求反向链接告诉集合何时会退出入口。当反向链接数目为零时，该元素就可以从集合中移除了。2.缓存缓存是一种数据结构，用于快速查找已经执行的操作结果。因此，如果一个操作执行起来很慢，对于常用的输入数据就可以将操作的结果缓存，并在下次调用该操作时使用缓存的数据。缓存通常都是以动态方式实现的，其中新的结果是在执行时添加到缓存中的。典型的算法如下：（1）检查结果是否在缓存中，如果在，就返回结果。（2）如果结果不在缓存中，就进行计算。（3）将计算出来的结果添加到缓存中，以便以后对该操作的调用可以使用。该算法的问题（或者说是潜在的内存泄漏）出在最后一步。如果调用该操作时有相当多的不同的输入，就将有相当多的结果存储在缓存中。很明显，这不是正确的方法。为了预防这种具有潜在破坏性的设计，程序必须确保对于缓存所使用的内存容量有一个上限。因此，更好的算法如下：（1）检查结果是否在缓存中，如果在，就返回结果。（2）如果结果不在缓存中，就进行计算。（3）如果缓存所占的空间过大，就移除缓存最久的结果。（4）将计算出来的结果添加到缓存中，以便以后对该操作的调用可以使用。
3.ClassLoaderJava中ClassLoader结构的使用为内存泄漏提供了许多可乘之机。正是该结构本身的复杂性使ClassLoader在内存泄漏方面存在如此多的问题。ClassLoader的特别之处在于它不仅涉及“常规”的对象引用，还涉及元对象引用，比如字段、方法和类。这意味着只要有对字段、方法、类或ClassLoader对象的引用，ClassLoader就会驻留在JVM中，因为ClassLoader本身可以关联许多类及其静态字段，所以就有许多内存被泄漏。
clone方法是在Object中定义的，而且是protected型的，只有实现了这个接口，才可以在该类的实例上调用clone方法，否则会抛出CloneNotSupportException。说clone方法并没有对对象是否属于cloneable类型进行检验这个观点是不正确的。因为cloneable接口的出现跟接口的正常使用没有任何关系，特别是它并不指定clone方法——该方法从Object类中继承而来，该接口只是作为一个标记。这句话通俗地说就是以下3点：首先，clone方法是Object类的一个方法，所以任何一个类都会自动拥有这一个方法。其次，这并不说明该类就可以调用clone了，因为Javac或者Java需要程序员显式地指明该类可以调用clone，方法就是写上这个字符串“implements Cloneable”。再次，这个字符串只是起一个指示作用，没有其他功能，这是由Javac或者Java规定的。
对象是类的一个实例，但是什么时候需要实例，什么时候不需要，该如何确认？有些类无须创建实例，直接定义就可以使用，系统也不报错。如何知道这个类必须用实例还是不需要用实例？
对象和实例从宏观的角度看，区别是：对象是同类事物的一种抽象表现形式，而实例是对象的具体化，一个对象可以实例化很多实例，对象就是一个模型，实例是照着这个模型生产的最终产品。实际上就是这样，一个对象可以实例化N个实例。就像根据一个模型可以制造多个实际的产品一样。不用实例化的：静态方法是为类提供的公共方法，也就是这个方法对所有属于这个类的对象适用。例如，假设为男人定义一个类，该类有个方法用来查询男人是否有喉结，那么从现阶段的生物进化来看，男人都是有喉结的。也就是不必具体到某个男人，就知道他有喉结。所以这个方法应定义为静态方法，因为是对所有的男人都适用。要实例化的：每个人都有身高、体重，当你要查询人的体重时，你肯定先要指定那个人的体重。这个过程就是相当于实例化，即具体到了个人。有些类却无须创建实例，直接定义就可以使用。这种类型往往是面向公众的，如政府机构提供了一系列的服务，这些服务对每个人都是适用的，所以这个可以是静态的。如何知道这个类必须用实例还是不需要用实例？这个和问题域有关，如前面所说，当你研究男人有没有喉结时，这个不用实例化就能查询到。当你要查询体重时，就要具体到某个人，就是要实例化。
（1）Java容器类库一共有两种主要类型：Collection和Map。Collection和Map的区别在于容器内每个“槽”所存储的元素个数不同。Collection类型中，每个“槽”只有一个元素；Map类型中，持有key-value关联（key叫做键，value叫做值）像一个小型数据库。所有的Java容器类都可以自动调整自己的尺寸。
（3）其他特征如下。① List、Set、Map将所有的对象一律视为Object类型。② Collection、List、Set、Map都是接口，不能实例化。继承自它们的ArrayList、Vector、HashTable、HashMap、stack是具体class，这些才可被实例化。③ Vector容器确切地知道它所持有的对象隶属什么类别。Vector不进行边界检查。
（4）关于Collections。Collections是针对集合类的一个帮助类，它提供了一系列静态方法实现对各种集合的搜索、排序、线程完全化等操作。相当于对Array进行类似操作的类——Arrays。
（5）如何选择容器类。① 容器类和Array的区别、择取。容器类仅能持有对象引用（指向对象的指针），而不是将对象信息复制一份至数列某位置，一旦将对象置入容器内，便损失了该对象的类别信息。② 在各种Lists中，最好的做法是以ArrayList作为默认选择。当插入、删除频繁时，使用LinkedList()；Vector总是比ArrayList慢；在各种Sets中，HashSet通常优于HashTree（插入、查找）。只有当需要产生一个经过排序的序列，才用TreeSet。HashTree的意义是用来维护其内元素的排序状态；在各种Maps中，HashMap用于快速查找。当元素个数固定时，最好使用Array，因为Array的效率是最高的。
请说明HashMap和Hashtable的区别
它们都属于Map接口的类，实现了将唯一键映射到特定的值上。HashMap类没有分类或者排序，它允许一个null键和多个null值。Hashtable类似于HashMap，但是不允许null键和null值。它也比HashMap慢，因为它是同步的。Hashtable继承自Dictionary类，而HashMap是Java 1.2引进的Mapinterface的一个实现。HashMap允许将null作为一个entry的key或者value，而Hashtable不允许，还有就是，HashMap把Hashtable的contains方法去掉了，改成containsvalue(Returns true if this map maps one or more keys tothe specified value)（如果相对应的map对应指定的value有多个key，则返回值为真）和containsKey(Returns true if this map contains amapping for the specified key)（如果对指定的key，map存在相应的映射则返回为真）。因为contains(Tests if some key maps into thespecified value in this hashtable)（检测哈希表中是否有value和key存在对应）方法容易让人引起误解。两者间最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供外同步。Hashtable和HashMap采用的hash/rehash算法类似，所以性能不会有很大的差异。
那么，多态的作用是什么呢？封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）。它们的目的都是为了代码重用。而多态则是为了实现另一个目的—接口重用！而且现实往往是：要有效重用代码很难，而真正最具有价值的重用是接口重用，因为“接口是公司最有价值的资源。设计接口比用一堆类来实现这个接口更费时间。而且接口需要耗费更昂贵的人力和时间。”其实，继承的为重用代码而存在的理由已经越来越薄弱，因为“组合”可以很好地取代继承的扩展现有代码的功能，而且“组合”的表现更好（至少可以防止“类爆炸”）。
override是指派生类重写基类的虚函数，就像某个类中重写了另一个类中的某个函数，重写的函数必须有一致的参数表和返回值。override一直没有合适的中文词汇来对应，在此译为“覆盖”更贴切。overload约定俗成地被翻译为“重载”，是指编写一个与已有函数同名但是参数表不同的函数。例如，一个函数既可以接受整型数作为参数，也可以接受浮点数作为参数。重载不是一种面向对象的编程，而只是一种语法规则。重载与多态没有什么直接关系。
成员函数被重载的特征如下：（1）相同的范围（在同一个类中）。（2）函数名字相同。（3）参数不同。（4）virtual关键字可有可无。覆盖的特征如下：（1）不同的范围（分别位于派生类与基类）。（2）函数名字相同。（3）参数相同。（4）基类函数必须有virtual关键字。
静态的方法不能被覆盖
组合（composition）是指通过对现有的对象进行拼装（组合）产生新的更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以，我们也说这种方式的代码复用是“黑盒式代码复用”
Java里在类中用super调用父类构造函数时，为什么调用语句必须是子类的第一条语句
如果想用super继承父类构造的方法，但是没有放在第一行的话，那么在super之前的语句，肯定是为了满足自己想要完成某些行为的语句，但是又用了super继承父类的构造方法。那么以前所做的修改就都回到以前，就是说又成了父类的构造方法了。
在Java中，有时还会遇到子类中的成员变量或方法与超类（有时也称父类）中的成员变量或方法同名。因为子类中的成员变量或方法名优先级高，所以子类中的同名成员变量或方法就隐藏了超类的成员变量或方法，但是我们如果想要使用超类中的这个成员变量或方法，就需要用到super。
关于String类的说明   
    "aaa777"是编译期常量，编译时已经能确定它的值，在编译好的class文件中，它已经在String Pool中了，此语句会在String Pool中查找
        等于"aaa777"的字符串（用equals(Object)方法确定），如果存在，就把引用返回，赋值给s1；若不存在，就会创建一个"aaa777"放在
        StringPool中，然后把引用返回，赋值给s1。由于String Pool只会维护一个值相同的String对象，上面两句得到的引用是String Pool
        中的同一个对象，所以它们引用相等。  
    在Java中，使用new关键字会创建一个新对象，在本例中，不管在StringPool中是否已经有值相同的对象，都会创建一个新的String对象存储
        在heap中，然后把引用返回，赋值给s1。本例中使用了String的publicString(String original)构造函数。由于s1是用new创建出的新
        对象，存储在heap中，s2指向的对象存储在String Pool中，它们肯定不是同一个对象，只是存储的字符串值相同，所以返回false。
    当调用intern方法时，如果String Pool中已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回池中的字符串，
        否则将此String对象添加到池中，并返回此String对象在String Pool中的引用。由于执行了s1 = s1.intern()，会使s1指向String Pool
        中值为"aaa777"的字符串对象，s2也指向了同样的对象，所以结果为true。
    由于进行连接的两个字符串都是常量，编译期就能确定连接后的值了，编译器会进行优化，直接把它们表示成"aaa777"存储到String Pool中，
        由于上边的s2="aaa777"已经在String Pool中加入了"aaa777"，此句会把s3指向和s2相同的对象，所以它们引用相同。此时仍然会创建
        出"aaa"和"777"两个常量，存储到String Pool中。
    StringBuffer面试关键点：（1）简单地认为.append()效率好于“+”是错误的。（2）不要使用new创建String。（3）注意.intern()的使用。
        （4）在编译期能够确定字符串值的情况下，使用“+”效率最高。（5）避免使用“+=”来构造字符串。（6）在声明StringBuffer对象的时候，
        指定合适的capacity，不要使用默认值（18）。（7）注意以下二者的区别，后者开辟了两个内存段。● String s = "a" + "b";● String s = "a";
    字符串对象的创建。由于字符串对象的大量使用（它是一个对象，一般而言，对象总在heap分配内存），Java中为了节省内存空间和运行时间
        （如比较字符串时，“==”比equals()快），在编译阶段就把所有的字符串文字放到一个文字池（pool of literal strings）中，而运行
        时文字池成为常量池的一部分。文字池的好处就是该池中所有相同的字符串常量被合并，只占用一个空间。对两个引用变量使用“==”判断
        它们的值（引用）是否相等，即指向同一个对象。    
    现在看“String s = new String("abc");”语句，这里“abc”本身就是pool中的一个对象，而在运行时执行new String()时，将pool中的对象
        复制一份放到heap中，并且把heap中的这个对象的引用交给s持有。这条语句就创建了两个String对象。
    “A = "a";”，引用的不是对象，此处创建了一个对象和一个引用A；“B = "b";”，说明同上；“A = A + B;”，说明同上，此处创建了一个对象，
        并由引用A来引用，那么原来A所指向的对象就成为垃圾对象，被回收；“StringBuffer D = new StringBuffer("abc");”，StringBuffer
        的特点是改变对象本身而不是创建新的对象，因此，此处及“D =D.append("567");”都是对同一个对象进行处理。而字符串对象也是一个
        对象，故有两个对象。
    1.sleep()sleep()是使线程停止一段时间的方法。在sleep时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其他线程可能
        正在运行，而且没有被调度为放弃执行，除非“醒来”的线程具有更高的优先级，或者正在运行的线程因为其他原因而阻塞。2.wait()当线
        程交互时，如果线程对一个同步对象x发出一个wait()调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。
    如果数据将在线程间共享，例如，正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就
        是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，
        就应该使用异步编程。在很多情况下采用异步途径往往更有效率。
    启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行，但并不意味着线程就会立
        即运行。run()方法可以产生必须退出的标志来停止一个线程。
    1NF：第一范式。如果关系模式R的所有属性的值域中每一个值都是不可再分解的值，则称R属于第一范式模式。如果某个数据库模式都是第一范
        式的，则称该数据库模式属于第一范式的数据库模式。第一范式的模式要求属性值不可再分裂成更小部分，即属性项不能由属性组合和组属
        性组成。2NF：第二范式。如果关系模式R为第一范式，并且R中每一个非主属性完全函数依赖于R的某个候选键，则称R为第二范式模式。如
        果某个数据库模式中每个关系模式都是第二范式，则称该数据库模式属于第二范式的数据库模式。（注：如果A是关系模式R的候选键的一个
        属性，则称A是R的主属性，否则称A是R的非主属性。）3NF：第三范式。如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的候
        选键，则称R是第三范式的模式。如果某个数据库模式中的每个关系模式都是第三范式，则称为3NF的数据库模式。BCNF：BC范式。如果关系
        模式R是第一范式，且每个属性都不传递依赖于R的候选键，那么称R是BCNF的模式。4NF：第四范式。设R是一个关系模式，D是R上的多值依
        赖集合。如果D中成立非平凡多值依赖X→→Y，X必是R的超键，那么称R是第四范式的模式。
    数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做，要么全不做，是一个不可分割的工作单位。事务的开始与结束可
        以由用户显式地控制。如果用户没有显式地定义事务，则由DBMS按默认的规定自动划分事务。事务具有原子性、一致性、独立性及持久性等
        特点。（1）事务的原子性是指一个事务要么全部执行，要么不执行。也就是说，一个事务不可能只执行一半就停止了。比如你从银行取钱，
        这个事务可以分成两个步骤：① 存折减款，② 拿到现金。不可能存折钱少了，而钱却没出来。这两步必须同时完成，要么都不完成。（2）
        事务的一致性是指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a+b=10，一个事务改变了a，那么b也应该随之改变。
        （3）事务的独立性是指两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。（4）事务的持久性是指事务运行成功
        以后，系统的更新是永久的，不会无缘无故地回滚。
    在SQL Server中，索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点，而非聚簇索引的叶节点
        仍然是索引节点，只不过有一个指针指向对应的数据块。聚簇索引确定表中数据的物理顺序。聚簇索引类似于电话簿（电话簿按照字母簿排序），
        后者按姓氏排列数据。由于聚簇索引规定数据在表中的物理存储顺序，因此，一个表只能包含一个聚簇索引，但该索引可以包含多个列（组合索引），
        就像电话簿按姓氏和名字进行组织一样。聚簇索引对于那些经常要搜索范围值的列特别有效。使用聚簇索引找到包含第一个值的行后，便可
        以确保包含后续索引值的行物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用聚簇索引可以迅速找到
        包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进
        行排序时经常要用到某一列，则可以将该表在该列上聚簇（物理排序），避免每次查询该列时都进行排序，从而节省成本。非聚簇索引与课
        本中的索引类似，数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。索引中的项目按索引键值的顺序存
        储，而表中的信息按另一种顺序存储（这可以由聚簇索引规定）。如果在表中未创建聚簇索引，则无法保证这些行具有任何特定的顺序。有
        索引就一定检索得快吗？答案是否。有些时候用索引还不如不用索引快，比如说，我们要检索表中共8000条记录，如果不用索引，需要访
        问8000条×1000B/8KB=1000个页面；如果使用索引，首先检索索引，访问8000条×10B/8KB=10个页面，得到索引检索结果，再根据索引检
        索结果去对应数据页面，由于是检索所有的数据，所以，需要再访问8000条×1000B/8KB=1000个页面，将全部数据读取出来，一共访问了1010
        个页面，这显然不如不用索引快
    游标用于定位结果集的行。通过判断全局变量@@FETCH_STATUS，可以判断游标是否到了最后，通常此变量不等于0表示出错或到了最后。
    执行数据库查询时，如果要查询的数据有很多，假设有1000万条，用什么办法可提高查询效率（速度）？在数据库方面或Java代码方面有什么优化的办法
    1.在数据库设计方面（1）建立索引。（2）分区（MySQL，比如按时间分区）。（3）尽量使用固定长度的字段。（4）限制字段长度。2.在数据
        库I/O方面（1）增加缓冲区。（2）如果涉及表的级联，不同的表存储在不同的磁盘上，以增加I/O速度。3.在SQL语句方面（1）优化SQL语
        句，减少比较次数。（2）限制返回的条目数（MySQL中用limit）。4.在Java方面如果是反复使用的查询，使用PreparedStatement减少
        查询次数。
    实际应用中，延迟敏感型会偏向于UDP，因为TCP并无延迟控制良策，反而通过自定义的协议栈和应用缓冲机制，有机会提供比较好的效果；带宽
        敏感型会比较偏向于TCP，因为应用开发要达到最佳效果，通常会更加专注于文件系统的缓存优化，而把传输任务交送给TCP处理；群组通信
        型会比较偏向于UDP，因为组播通信并没有确定的回应人，所以组播传输几乎完全基于UDP。计算机密集型和带宽敏感型类似，通常会偏向于
        TCP，因为希望上层优化开发需要花费的时间更多，通常会把传输交给TCP。DNS协议也属于这个类型，但属于一个比较例外。它既采用UDP，
        又采用TCP，主要考虑到DNS的Client很多是延迟敏感型和资源集约型；资源集约型相对会偏向于UDP，因为剥离TCP堆栈以后，内核可以简
        化很多。一些简化的控制机制也很容易在UDP based协议上实现，例如，SNMP这类协议广泛采用UDP；大规模并发用户类型不同于技术流派的
        问题，当初QQ采用UDP4000/8000并非仅仅考虑到系统负载之类的状况，而是因为混杂型、故障型的原因更多，就好像MSN采用TCP，同样也
        可以承担大规模并发用户。但是QQ的设计实践很好地适应了中国教育网、电信、联通互联的故障型状况，在最短时间内获得了最大批的用
        户。而现在，QQ很多情形下都采用TCP 80443来穿越防火墙，主要通信已经成为TCP行为。任务型通常会按照具体任务来确定，TCP是首选；
        混杂型属于个人爱好，例如，P2P的应用，用UDP、TCP均可以写好；故障型通常会采用改进协议栈的TCP或者UDP。因为丢包率、延迟抖动、
        乱序等问题的存在，标准的TCP的时钟、重传机制未必能够很好适应。这时候就会修改TCP协议栈或者采用自定义开发协议栈（通常基于GRE
        或者UDP）。在这种情况下，使用UDP其实并没有特别的性能优势，但由于UDP广泛被各类网络允许通过，所以才使用UDP。可以看到，从传
        输性能角度考虑，通常不是选择UDP的理由，而更容易选择TCP，因为应用开发人员可以更集中精力提高上层文件处理性能和管理效率，而
        不必为了有限的潜在性能而去优化协议栈，就好像TFTP，TFTP的“T”代表琐碎、不重要的意思，即TFTP设计用来传输一些零碎的物件，所
        以，保障可用性高于性能需求。
    TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。第一次握手：建立连接时，客户端发送SYN包（SYN=j）到服务器，
        并进入SYN_SEND状态，等待服务器确认。第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包
        （SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），
        此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手后，客户端与服务器开始传送数据，在上述过程中，
        还有一些重要的概念。
    （1）未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（SYN=j）开设一个条目，该条目表明服务器
        已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认
        包时，删除该条目，服务器进入ESTABLISHED状态。（2）* SYN：同步标志。同步序列编号（Synchronize Sequence Numbers）栏有效。
        该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端（一般是客户端）的初始序
        列编号。在这里，可以把TCP序列编号看作是一个范围从0到4、294、967、295的32位计数器。通过TCP连接交换的数据中每一个字节都经过
        序列编号。在TCP报头中的序列编号栏包括TCP分段中第一个字节的序列编号。（3）*ACK：确认标志。确认编号（Acknowledgement Number）
        栏有效。大多数情况下，该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号（w+1，Figure-1）为下一个预期的序列编号，同
        时提示远端系统已经成功地接收所有的数据。（4）*RST：复位标志。复位标志有效。用于复位相应的TCP连接。（5）*URG：紧急标志。紧
        急（The urgent pointer）标志有效。紧急标志置位。（6）*PSH：推标志。该标志置位时，接收端不将该数据进行队列处理，而是尽可
        能快地将数据转由应用处理。在处理telnet或rlogin等交互模式的连接时，该标志总是置位的。（7）*FIN：结束标志。带有该标志置位
        的数据包用来结束一个TCP会话，但对应端口仍处于开放状态，准备接收后续数据。
    网络中常见的ping命令基于什么协议：ping.exe的原理是，向指定的IP地址发送一定长度的数据包，按照约定，若指定的IP地址存在的话，会
        返回同样大小的数据包，当然，若在特定的时间内没有返回，就是“超时”，就认为指定的IP地址不存在。由于ping使用的是ICMP协议，有
        些防火墙软件会屏蔽掉ICMP协议，所以有时候ping的结果只能作为参考，ping不通并不能说明对方IP不存在。ping命令是一个非常有用的
        网络命令，大家常用它来测试网络联通情况。但同时它也是把“双刃剑”，别人使用ping命令能探测到你计算机上的很多敏感信息，造成不安
        全。出于安全考虑，防止ping的方法也有很多，比如防火墙，又比如创建一个禁止所有计算机ping本机IP地址的安全策略。由于ping使用
        的是ICMP协议，有些防火墙软件会屏蔽掉ICMP协议。IPSec安全策略是关于如何“防ping”的，其原理是通过新建一个IPSec策略来过滤掉本
        机所有的ICMP数据包实现的。这样，确实是可以有效地“防ping”，但同时也会留下后遗症。因为ping命令和ICMP协议（Internet Control 
        Message Protocol）有着密切的关系，在ICMP协议的应用中包含有11种报文格式，其中ping命令就是利用ICMP协议中的“EchoRequest”报
        文进行工作的。但IPSec安全策略防ping时采用“格杀勿论”的方法，把所有的ICMP报文全部过滤掉，特别是很多有用的其他格式的报文也
        同时被过滤掉了。
    子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩
        码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进
        制数字“0”表示，其中“1”有24个，代表与此相对应的IP地址左边24位是网络号；“0”有8个，代表与此相对应的IP地址右边8位是主机号。
        这样，子网掩码就确定了一个IP地址的32位二进制数字中哪些是网络号，哪些是主机号。这对于采用TCP/IP协议的网络来说非常重要，只
        有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。子网掩码可以确定一个网络层地址哪一部分是网络
        号，哪一部分是主机号。子网掩码的作用就是获取主机IP的网络地址信息，用于区别主机通信根据不同的情况选择不同的路径。其中A类网
        络的子网掩码为255.0.0.0，B类网络为255.255.0.0，C类网络为255.255.255.0。通过IP地址的二进制与子网掩码的二进制进行与运算来
        确定某个设备的网络地址，也就是说，通过子网掩码分辨一个网络的网络部分和主机部分。子网掩码一旦设置，网络地址和主机地址就固定了。